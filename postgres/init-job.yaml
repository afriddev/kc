apiVersion: batch/v1
kind: Job
metadata:
  name: keycloak-db-init
  namespace: his-keycloak
  annotations:
    # Restart policy for idempotency (re-run if failed)
    "helm.sh/hook": "post-install,post-upgrade"
    "helm.sh/hook-weight": "5"  # Run after Postgres starts
    "helm.sh/hook-delete-policy": "hook-succeeded"
spec:
  backoffLimit: 3  # Retry up to 3 times if fails
  template:
    spec:
      restartPolicy: Never  # Job doesn't restart on failure (use backoffLimit instead)
      containers:
      - name: init-db
        image: postgres:17-alpine
        command:
        - /bin/sh
        - -c
        - |
          # Wait for Postgres service to be reachable
          echo "Waiting for Postgres to be ready..."
          for i in {1..30}; do
            if nc -z postgres 5432; then
              echo "Postgres is ready!"
              break
            fi
            echo "Waiting for Postgres... ($i/30)"
            sleep 2
          done
          if ! nc -z postgres 5432; then
            echo "Timeout: Postgres not ready after 60s"
            exit 1
          fi

          # Now connect and init DB/user
          set -e
          PGPASSWORD=$(POSTGRES_PASSWORD) psql -h postgres -U $(POSTGRES_USER) -d postgres -v ON_ERROR_STOP=1 <<EOSQL
          DO \$\$
          BEGIN
            IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = '$$KEYCLOAK_DB_USER') THEN
              CREATE ROLE $$KEYCLOAK_DB_USER WITH LOGIN PASSWORD '$$KEYCLOAK_DB_PASSWORD' CREATEDB;
            ELSE
              ALTER ROLE $$KEYCLOAK_DB_USER WITH LOGIN PASSWORD '$$KEYCLOAK_DB_PASSWORD' CREATEDB;
            END IF;
          END
          \$\$;
          SELECT 'CREATE DATABASE $$KEYCLOAK_DB' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = '$$KEYCLOAK_DB')\gexec;
          GRANT ALL PRIVILEGES ON DATABASE $$KEYCLOAK_DB TO $$KEYCLOAK_DB_USER;
          \c $$KEYCLOAK_DB;
          GRANT ALL PRIVILEGES ON SCHEMA public TO $$KEYCLOAK_DB_USER;
          GRANT ALL ON ALL TABLES IN SCHEMA public TO $$KEYCLOAK_DB_USER;
          GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO $$KEYCLOAK_DB_USER;
          ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO $$KEYCLOAK_DB_USER;
          ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO $$KEYCLOAK_DB_USER;
          EOSQL
          echo "DB initialization completed successfully!"
        env:
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: keycloak-postgres-secrets
              key: POSTGRES_USER
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: keycloak-postgres-secrets
              key: POSTGRES_PASSWORD
        - name: KEYCLOAK_DB
          valueFrom:
            secretKeyRef:
              name: keycloak-postgres-secrets
              key: POSTGRES_DB
        - name: KEYCLOAK_DB_USER
          valueFrom:
            secretKeyRef:
              name: keycloak-postgres-secrets
              key: KEYCLOAK_DB_USER
        - name: KEYCLOAK_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: keycloak-postgres-secrets
              key: KEYCLOAK_DB_PASSWORD
        # Resources for reliability
        resources:
          requests:
            cpu: "100m"
            memory: "128Mi"
      # Use initContainer to ensure service is available (optional, but adds robustness)
      initContainers:
      - name: wait-for-postgres
        image: busybox:1.35
        command:
        - /bin/sh
        - -c
        - |
          echo "Waiting for Postgres service..."
          for i in {1..60}; do
            if nslookup postgres.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local >/dev/null 2>&1; then
              echo "Service DNS ready!"
              break
            fi
            sleep 1
          done
